<title>üëÅÔ∏è</title>
<link rel=icon
    href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="1.1em" font-size="75">üëÅÔ∏è</text></svg>'>
<style>
    html, body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: #262626;
    }
    canvas {
        position: absolute;
    }
</style>

<!-- fallback to cdn -->
<script src="lib/swissgl.js"></script>
<script>window.SwissGL || document.write('<script src="https://cdn.jsdelivr.net/gh/google/swissgl@main/swissgl.js">\x3C/script>')</script>
<script src="lib/p5.js"></script>
<script>window.p5 || document.write('<script src="https://cdn.jsdelivr.net/npm/p5@1.11.2/lib/p5.js">\x3C/script>')</script>

<script>
function mod(x, n) {
    return fract(x / n) * n
}
function clamp(x, a, b) {
    return max(min(x, b), a)
}
function sign(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0
}
function mouse_in_rect({x, y, w, h}) {
    return mouseX >= x && mouseX <= x + w
        && mouseY >= y && mouseY <= y + h
}

const ease = {
    inQuad(t) { return t * t },
    outQuad(t) { return t * (2 - t) },
    inOutQuad(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
    inCubic(t) { return t * t * t },
    outCubic(t) { return (--t) * t * t + 1 },
    inOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
    inQuart(t) { return t * t * t * t },
    outQuart(t) { return 1 - (--t) * t * t * t },
    inOutQuart(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
    inQuint(t) { return t * t * t * t * t },
    outQuint(t) { return 1 + (--t) * t * t * t * t },
    inOutQuint(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t },
}

class Updater {
    constructor({name, get_target_params, init, update, draw, interact}) {
        Object.assign(this, {name, get_target_params, init, update, draw, interact})
    }
}

const huemap = new Updater({
    name: "huemap",
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "rgba32f",
            story: 2,
            tag: "cells",
        }
    },
    init: function() {
        return glsl({
            seed: Math.random() * 12417,
            FP: "hash(ivec3(I, seed)), 1",
        }, { ...this.get_target_params() })
    },
    update: function() {
        glsl({
            seed: Math.random() * 12417,
            FP: `
            float sigmoid(float x) {
                return 1.0 / (1.0 + exp(-x));
            }

            void fragment() {
                // re-init on resize
                FOut = Src(I);
                vec3 rng_0 = hash(ivec3(I, seed));
                if (FOut.a == 0.0 || isnan(FOut.r)) {
                    FOut = vec4(rng_0, 1);
                    return;
                }

                // get random updater, get states
                vec3 rng_1 = hash(ivec3(I, seed + 1.0));
                ivec2 updater_offset = ivec2(round(rng_1.xy * 2.0 - 1.0));
                ivec2 updater_pos = (I + updater_offset + Src_size()) % Src_size();
                vec3 updater_state = Src(updater_pos).rgb;
                vec3 self_state = FOut.rgb;

                // mix based on relative distance from grey
                float updater_grey = dot(updater_state, vec3(1.0 / 3.0));
                float self_grey = dot(self_state, vec3(1.0 / 3.0));
                float updater_dist = length(updater_state - updater_grey);
                float self_dist = length(self_state - self_grey);
                float updater_rel_dist = updater_dist / (updater_dist + self_dist);
                float win_strength = 20.0;
                float updater_strength = sigmoid((updater_rel_dist - 0.5) * win_strength);
                vec3 new_state = mix(self_state, updater_state, updater_strength);

                // add noise
                vec3 rng_2 = hash(ivec3(I, seed + 2.0));
                float temperature = 0.01;
                new_state += (rng_2 * 2.0 - 1.0) * temperature;

                // clamp in range and avoid corner bias
                new_state = clamp(new_state, 0.0, 1.0);
                float new_state_grey = dot(new_state, vec3(1.0 / 3.0));
                vec3 new_state_chroma = new_state - new_state_grey;
                float new_state_dist = min(length(new_state_chroma), sqrt(3.0 / 8.0));
                new_state = new_state_grey + normalize(new_state_chroma) * new_state_dist;

                FOut = vec4(new_state, 1);
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            cells: glsl.buffers.cells[0],
            FP: `
            vec2 offset_uv = vec2(offset) / vec2(cells_size());
            vec2 uv = mod(UV / scale + offset_uv, vec2(1));
            FOut = cells(uv);
        `})
    },
    interact: function(mx_square, my_square) {
        const cur_cells = glsl({
            cells: glsl.buffers.cells[0],
            FP: "cells(I)",
        }, {
            ...this.get_target_params(),
            story: 1,
            tag: "cur_cells",
        })
        glsl({
            seed: Math.random() * 12417,
            mouse_square: [mx_square, my_square],
            brush_size: 0.1 / zoom.scale,
            cells: cur_cells[0],
            FP: `
            vec2 size = vec2(cells_size());
            float aspect = size.x / size.y;
            vec2 aspect_scale = (
                aspect > 1.0
                ? vec2(aspect, 1.0)
                : vec2(1.0, 1.0 / aspect)
            );
            vec2 uv_square = 0.5 + (UV - 0.5) * aspect_scale;
            for (int i = -1; i <= 1; ++i) {
                for (int j = -1; j <= 1; ++j) {
                    vec2 uv_tile = uv_square + vec2(i, j) * aspect_scale;
                    if (distance(uv_tile, mouse_square) < brush_size) {
                        FOut = vec4(hash(ivec3(I, seed)), 1);
                        return;
                    }
                }
            }
            FOut = cells(I);
        `}, glsl.buffers.cells[0])
    }
})
const r8_cycle = new Updater({
    ...huemap,
    name: "r8 cycle",
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "r8",
            story: 2,
            tag: "cells",
        }
    },
    update: function() {
        glsl({
            seed: Math.random() * 12417,
            FP: "vec3(mod(Src(I).r + 0.01, 1.0)), 1"
        }, { ...this.get_target_params(), format: "r8" })
    },
})
const add_max = new Updater({
    ...huemap,
    name: "add max",
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "r32i",
            story: 2,
            tag: "cells_int",
        }
    },
    init: function() {
        return glsl({
            seed: Math.random() * 12417,
            FP: "hash(ivec3(I, seed)) * 255.0, 1",
        }, { ...this.get_target_params() })
    },
    update: function() {
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                // todo: get macros to work for int textures
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                // get random updater, get states
                vec3 rng_1 = hash(ivec3(I, seed + 1.0));
                ivec2 updater_offset = ivec2(round(rng_1.xy * 2.0 - 1.0));
                ivec2 updater_pos = (I + updater_offset + cells_size) % cells_size;
                if (updater_pos == I) {
                    return;
                }
                int updater_state = texelFetch(cells, updater_pos, 0).r;
                int self_state = FOut.r;

                // add max
                FOut.r = max(updater_state + 2, self_state + 2) % 256;
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 f = texture(cells, uv);
                FOut = vec4(f) / 255.0;

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = (f.r / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);
            }
        `})
    },
    interact: function(mx_square, my_square) {
        const cur_cells = glsl({
            cells: glsl.buffers.cells_int[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                FOut = texture(cells, UV);
            }
        `}, {
            ...this.get_target_params(),
            story: 1,
            tag: "cur_cells_int",
        })
        glsl({
            seed: Math.random() * 12417,
            mouse_square: [mx_square, my_square],
            brush_size: 0.1 / zoom.scale,
            cells: cur_cells[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                vec2 size = vec2(textureSize(cells, 0));
                float aspect = size.x / size.y;
                vec2 aspect_scale = (
                    aspect > 1.0
                    ? vec2(aspect, 1.0)
                    : vec2(1.0, 1.0 / aspect)
                );
                vec2 uv_square = 0.5 + (UV - 0.5) * aspect_scale;
                for (int i = -1; i <= 1; ++i) {
                    for (int j = -1; j <= 1; ++j) {
                        vec2 uv_tile = uv_square + vec2(i, j) * aspect_scale;
                        if (distance(uv_tile, mouse_square) < brush_size) {
                            FOut = ivec4(ivec3(hash(ivec3(I, seed)) * 255.0), 1);
                            return;
                        }
                    }
                }
                FOut = texture(cells, UV);
            }
        `}, glsl.buffers.cells_int[0])
    }
})
const uhh = new Updater({
    ...add_max,
    name: "uhh",
    update: function() {
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                // todo: get macros to work for int textures
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                // get random updater, get states
                vec3 rng_1 = hash(ivec3(I, seed + 1.0));
                ivec2 updater_offset = ivec2(round(rng_1.xy * 2.0 - 1.0));
                ivec2 updater_pos = (I + updater_offset + cells_size) % cells_size;
                if (updater_pos == I) {
                    return;
                }
                int updater_state = texelFetch(cells, updater_pos, 0).r;
                int self_state = FOut.r;

                // add max
                FOut.r = max(updater_state + 3, self_state + 3) % 256;
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 f = texture(cells, uv);
                FOut = vec4(vec3(0), 1);
                FOut.b = float(f.r) / 512.0;
                FOut.r = float(f.r % 3 + 2) / 16.0;
                FOut.g = float(f.r % 3 + 1) / 8.0;

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = (f.r / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);
            }
        `})
    },
})
const uhh2 = new Updater({
    ...add_max,
    name: "uhh2",
    update: function() {
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                // todo: get macros to work for int textures
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                // get random updater, get states
                vec3 rng_1 = hash(ivec3(I, seed + 1.0));
                ivec2 updater_offset = ivec2(round(rng_1.xy * 2.0 - 1.0));
                ivec2 updater_pos = (I + updater_offset + cells_size) % cells_size;
                if (updater_pos == I) {
                    return;
                }
                int updater_state = texelFetch(cells, updater_pos, 0).r;
                int self_state = FOut.r;

                // add max
                if ((updater_state + self_state) % 3 == 0) {
                    // FOut.r = max(updater_state + 1, self_state + int(rng_1.z * 3.0)) % 256;
                    FOut.r = max(updater_state + 6, self_state + 6) % 128;
                }
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 f = texture(cells, uv);
                FOut = vec4(vec3(0), 1);
                FOut.b = float(f.r) / 512.0;
                FOut.r = float(f.r % 2 + 2) / 16.0;
                FOut.g = float(f.r % 3 + 1) / 8.0;

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = (f.r / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);
            }
        `})
    },
})
const event_pairs = new Updater({
    name: "event pairs",
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "rg32i",
            story: 2,
            tag: "cells_int2",
        }
    },
    init: function() {
        return glsl({
            FP: "1, 0, 0, 1",
        }, { ...this.get_target_params() })
    },
    update: function() {
        // choose cell to update
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                // P(selected) = (
                //     P(chose self) * P(only 1 of 8 neighbors chose this)
                //     + P(chose other) * P(other chose self) * P(7 neighbors didn't choose that)
                // )
                // P(chose self) = x
                // P(chose other) = 1 - x
                // P(neighbor chose this) = (1 - x) / 8
                // P(neighbor didn't choose that) = 1 - (1 - x) / 8
                // P(only 1 of 8 neighbors chose this) = C(8,1) * ((1 - x) / 8)^1 * (1 - (1 - x) / 8)^7
                // = 8 * (1 - x) / 8 * (1 - (1 - x) / 8)^7
                // = (1 - x) * (1 - (1 - x) / 8)^7
                // P(7 neighbors didn't choose that) = (1 - (1 - x) / 8)^7
                // P(selected) = (
                //     x * (1 - x) * (1 - (1 - x) / 8)^7
                //     + (1 - x) * x * (1 - (1 - x) / 8)^7
                // )
                // = (1 - (1 - x) / 8)^7 * (x * (1 - x) + (1 - x) * x)
                // = (1 - (1/8 - x/8))^7 * 2x * (1 - x)
                // = (7/8 + x/8)^7 * 2x * (1 - x)
                // -> max is (1590772 * sqrt(2) - 559955) / 5038848 = 0.335
                //    at 2 * sqrt(2) / 3 - 1 / 3 = 0.609

                vec3 rng_1 = hash(ivec3(I, seed + 1.0));

                // ivec2 to_update = ivec2(round(rng_1.xy * 5.0 - 2.5));
                // to_update = (to_update + 2) % ivec2(3) - 1;
                // to_update += 1;
                // FOut.g = to_update.y * 3 + to_update.x % 3;

                // FOut.g = int(rng_1.x * 9.0);

                if (rng_1.x < 0.6094757) {
                    FOut.g = 4;
                } else {
                    // note: could bias edges for more circular diffusion
                    FOut.g = int(rng_1.y * 8.0);
                    if (FOut.g > 3) {
                        FOut.g += 1;
                    }
                }
            }
        `}, { ...this.get_target_params() })
        // update (just select here) pairs where a cell chose self
        // and 1 neighbor chose the cell
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            ivec2 g_to_dir(int g) {
                return ivec2(g % 3 - 1, g / 3 - 1);
            }
            ivec2 wrap_pos(ivec2 pos, ivec2 cells_size) {
                return (pos + cells_size) % cells_size;
            }
            bool is_target(ivec2 pos) {
                if (texelFetch(cells, pos, 0).g != 4) {
                    return false;
                }
                ivec2 cells_size = textureSize(cells, 0);
                int updater_count = 0;
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) {
                            continue;
                        }
                        ivec2 neighbor_offset = ivec2(dx, dy);
                        ivec2 neighbor_pos = wrap_pos(pos + neighbor_offset, cells_size);
                        ivec2 neighbor_choice = g_to_dir(texelFetch(cells, neighbor_pos, 0).g);
                        if (neighbor_choice == -neighbor_offset) {
                            updater_count++;
                        }
                    }
                }
                return updater_count == 1;
            }

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                if (is_target(I)) {
                    // mark as target
                    FOut.g += 9 * 2;
                } else if (FOut.g != 4) {
                    ivec2 target_dir = g_to_dir(FOut.g);
                    ivec2 target_pos = wrap_pos(I + target_dir, cells_size);
                    if (is_target(target_pos)) {
                        // mark as updater
                        FOut.g += 9;
                    }
                }
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int2[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            ivec2 g_to_dir(int g) {
                return ivec2(g % 3 - 1, g / 3 - 1);
            }

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 f = texture(cells, uv);
                FOut = vec4(vec3(0), 1);
                if (f.g >= 9 && f.g < 18) {
                    FOut.r = 1.0;
                    // blue corner to connect pairs
                    ivec2 target_dir = g_to_dir(f.g - 9);
                    vec2 cell_uv = mod(uv * vec2(cells_size), vec2(1));
                    if (ivec2(floor(cell_uv * 3.0 - 1.0)) == target_dir) {
                        FOut.rb = vec2(0, 1);
                    }
                } else if (f.g == 22) {
                    FOut.g = 1.0;
                }
                // if (dot(FOut.rgb, vec3(1)) > 0.0) {
                //     FOut.rgb = vec3(1);
                // }

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = ((f.g - 9) / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);
            }
        `})
    },
    interact: function(mx_square, my_square) {
        const cur_cells = glsl({
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                FOut = texture(cells, UV);
            }
        `}, {
            ...this.get_target_params(),
            story: 1,
            tag: "cur_cells_int2",
        })
        glsl({
            seed: Math.random() * 12417,
            mouse_square: [mx_square, my_square],
            brush_size: 0.1 / zoom.scale,
            cells: cur_cells[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                vec2 size = vec2(textureSize(cells, 0));
                float aspect = size.x / size.y;
                vec2 aspect_scale = (
                    aspect > 1.0
                    ? vec2(aspect, 1.0)
                    : vec2(1.0, 1.0 / aspect)
                );
                vec2 uv_square = 0.5 + (UV - 0.5) * aspect_scale;
                for (int i = -1; i <= 1; ++i) {
                    for (int j = -1; j <= 1; ++j) {
                        vec2 uv_tile = uv_square + vec2(i, j) * aspect_scale;
                        if (distance(uv_tile, mouse_square) < brush_size) {
                            FOut = ivec4(ivec3(hash(ivec3(I, seed)) * 255.0), 1);
                            return;
                        }
                    }
                }
                FOut = texture(cells, UV);
            }
        `}, glsl.buffers.cells_int2[0])
    }
})
const power = new Updater({
    name: "power",
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "rg32i",
            story: 2,
            tag: "cells_int2",
        }
    },
    init: function() {
        return glsl({
            FP: "2, 0, 0, 1",
        }, { ...this.get_target_params() })
    },
    update: function() {
        // choose cell to update
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                vec3 rng_1 = hash(ivec3(I, seed + 1.0));

                // find optimal self selection for plus neighborhood
                // P(selected) = (
                //     P(chose self) * P(only 1 of 4 neighbors chose this)
                //     + P(chose other) * P(other chose self) * P(3 neighbors didn't choose that)
                // )
                // P(chose self) = x
                // P(chose other) = 1 - x
                // P(neighbor chose this) = (1 - x) / 4
                // P(neighbor didn't choose that) = 1 - (1 - x) / 4
                // P(only 1 of 4 neighbors chose this) = C(4,1) * ((1 - x) / 4)^1 * (1 - (1 - x) / 4)^3
                // = 4 * (1 - x) / 4 * (1 - (1 - x) / 4)^3
                // = (1 - x) * (1 - (1 - x) / 4)^3
                // P(3 neighbors didn't choose that) = (1 - (1 - x) / 4)^3
                // P(selected) = (
                //     x * (1 - x) * (1 - (1 - x) / 4)^3
                //     + (1 - x) * x * (1 - (1 - x) / 4)^3
                // )
                // = (1 - (1 - x) / 4)^3 * (x * (1 - x) + (1 - x) * x)
                // = (1 - (1/4 - x/4))^3 * 2x * (1 - x)
                // = (3/4 + x/4)^3 * 2x * (1 - x)
                // -> max is 2187 / 6250 = 0.34992
                //    at 2 * sqrt(2) / 3 - 1 / 3 = 0.6

                if (rng_1.x < 0.6) {
                    FOut.g = 4;
                } else {
                    FOut.g = int(rng_1.y * 4.0) * 2 + 1;
                }
            }
        `}, { ...this.get_target_params() })
        // update pairs where a cell chose self
        // and 1 neighbor chose the cell
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            ivec2 g_to_dir(int g) {
                return ivec2(g % 3 - 1, g / 3 - 1);
            }
            ivec2 wrap_pos(ivec2 pos, ivec2 cells_size) {
                return (pos + cells_size) % cells_size;
            }
            ivec2 is_target(ivec2 pos) {
                /// returns (is_target, updater_val)

                if (texelFetch(cells, pos, 0).g != 4) {
                    return ivec2(0, 0);
                }
                ivec2 cells_size = textureSize(cells, 0);
                int updater_count = 0;
                ivec2 result = ivec2(0);
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) {
                            continue;
                        }
                        ivec2 neighbor_offset = ivec2(dx, dy);
                        ivec2 neighbor_pos = wrap_pos(pos + neighbor_offset, cells_size);
                        ivec4 neighbor_val = texelFetch(cells, neighbor_pos, 0);
                        ivec2 neighbor_choice = g_to_dir(neighbor_val.g);
                        if (neighbor_choice == -neighbor_offset) {
                            updater_count++;
                            result.y = neighbor_val.r;
                        }
                    }
                }
                result.x = int(updater_count == 1);
                return result;
            }

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                // re-init on resize
                if (FOut.r == 0) {
                    FOut = ivec4(2, 0, 0, 1);
                    return;
                }

                vec3 rng_2 = hash(ivec3(I, seed + 2.0));
                ivec2 is_target_result = is_target(I);
                if (is_target_result.x == 1) {
                    // target
                    int updater_val = is_target_result.y;
                    if (updater_val == FOut.r) {
                        // merge here
                        FOut.r = FOut.r * 2;
                        if (FOut.r >= 4096) {
                            FOut.r = rng_2.x < 0.2 ? 2 : 4;
                        }
                    } else if (updater_val >= FOut.r) {
                        // updater moves here
                        FOut.r = updater_val;
                    }
                } else if (FOut.g != 4) {
                    ivec2 target_dir = g_to_dir(FOut.g);
                    ivec2 target_pos = wrap_pos(I + target_dir, cells_size);
                    if (is_target(target_pos).x == 1) {
                        // updater
                        int target_val = texelFetch(cells, target_pos, 0).r;
                        if (FOut.r >= target_val) {
                            // merged or moved from here
                            FOut.r = rng_2.x < 0.8 ? 2 : 4;
                        }
                    }
                }
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int2[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            ivec2 g_to_dir(int g) {
                return ivec2(g % 3 - 1, g / 3 - 1);
            }
            ivec2 wrap_pos(ivec2 pos, ivec2 cells_size) {
                return (pos + cells_size) % cells_size;
            }

            vec3[] colors = vec3[](
                vec3(203.0, 185.0, 147.0) / 255.0,
                vec3(238.0, 228.0, 218.0) / 255.0,
                vec3(236.0, 224.0, 202.0) / 255.0,
                vec3(239.0, 178.0, 124.0) / 255.0,
                vec3(245.0, 149.0, 101.0) / 255.0,
                vec3(245.0, 124.0, 95.0) / 255.0,
                vec3(246.0, 96.0, 59.0) / 255.0,
                vec3(237.0, 206.0, 113.0) / 255.0,
                vec3(237.0, 204.0, 99.0) / 255.0,
                vec3(236.0, 200.0, 90.0) / 255.0,
                vec3(231.0, 194.0, 87.0) / 255.0,
                vec3(238.0, 194.0, 46.0) / 255.0
            );

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 self = texture(cells, uv);
                FOut = vec4(vec3(colors[int(log2(float(self.r)))]), 1);
                vec2 cell_uv = mod(uv * vec2(cells_size), vec2(1));
                cell_uv = 0.5 + (cell_uv - 0.5) / 0.8767;
                float border_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                if (cell_uv.x < 0.0 || cell_uv.x > 1.0 || cell_uv.y < 0.0 || cell_uv.y > 1.0) {
                    FOut = mix(FOut, vec4(colors[0], 1), border_visibility);
                }

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = (self.r / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);

                // todo: show 4 digits, more distinct colors
            }
        `})
    },
    interact: function(mx_square, my_square) {
        const cur_cells = glsl({
            cells: glsl.buffers.cells_int2[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                FOut = texture(cells, UV);
            }
        `}, {
            ...this.get_target_params(),
            story: 1,
            tag: "cur_cells_int2",
        })
        glsl({
            seed: Math.random() * 12417,
            mouse_square: [mx_square, my_square],
            brush_size: 0.1 / zoom.scale,
            cells: cur_cells[0],
            FP: `
            uniform isampler2D cells;

            void fragment() {
                vec2 size = vec2(textureSize(cells, 0));
                float aspect = size.x / size.y;
                vec2 aspect_scale = (
                    aspect > 1.0
                    ? vec2(aspect, 1.0)
                    : vec2(1.0, 1.0 / aspect)
                );
                vec2 uv_square = 0.5 + (UV - 0.5) * aspect_scale;
                for (int i = -1; i <= 1; ++i) {
                    for (int j = -1; j <= 1; ++j) {
                        vec2 uv_tile = uv_square + vec2(i, j) * aspect_scale;
                        if (distance(uv_tile, mouse_square) < brush_size) {
                            int val = hash(ivec3(I, seed)).r < 0.8 ? 2 : 4;
                            FOut = ivec4(val, 0, 0, 1);
                            return;
                        }
                    }
                }
                FOut = texture(cells, UV);
            }
        `}, glsl.buffers.cells_int2[0])
    }
})
const learn_add = new Updater({
    name: "learn add",
    // todo: make this uint (add support)
    get_target_params: function() {
        return {
            scale: 1 / cell_size / window.devicePixelRatio,
            format: "r32i",
            story: 2,
            tag: "cells_int",
        }
    },
    init: function() {
        // cell spec:
        // 4b: value, 1b: accepting updates, 3b: update dir
        // note: has 24 unused bits for now
        return glsl({
            seed: Math.random() * 12417,
            FP: "hash(ivec3(I, seed)) * 255.0, 1",
        }, { ...this.get_target_params() })
    },
    update: function() {
        // choose cell to update
        glsl({
            seed: Math.random() * 12417,
            cells: glsl.buffers.cells_int[0],
            FP: `
            uniform isampler2D cells;

            ivec2 update_dir(int x) {
                if ((x & 8) == 1) {
                    return ivec2(0, 0);
                }
                x &= 7;
                if (x >= 4) { x++; }
                return ivec2(x % 3 - 1, x / 3 - 1);
            }
            ivec2 wrap_pos(ivec2 pos, ivec2 cells_size) {
                return (pos + cells_size) % cells_size;
            }
            ivec2 is_target(ivec2 pos) {
                /// returns (is_target, updater_val (if is target))

                if ((texelFetch(cells, pos, 0).r & 8) == 0) {
                    return ivec2(0, 0);
                }
                ivec2 cells_size = textureSize(cells, 0);
                int updater_count = 0;
                ivec2 result = ivec2(0);
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) {
                            continue;
                        }
                        ivec2 neighbor_offset = ivec2(dx, dy);
                        ivec2 neighbor_pos = wrap_pos(pos + neighbor_offset, cells_size);
                        ivec4 neighbor_val = texelFetch(cells, neighbor_pos, 0);
                        ivec2 neighbor_choice = update_dir(neighbor_val.r);
                        if (neighbor_choice == -neighbor_offset) {
                            updater_count++;
                            result.y = neighbor_val.r;
                        }
                    }
                }
                result.x = int(updater_count == 1);
                return result;
            }

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                FOut = texelFetch(cells, I, 0);

                ivec2 is_target_result = is_target(I);
                if (is_target_result.x == 1) {
                    // target, swap values
                    FOut.r = is_target_result.y;
                } else if ((FOut.r & 8) == 0) {
                    ivec2 target_dir = update_dir(FOut.r);
                    ivec2 target_pos = wrap_pos(I + target_dir, cells_size);
                    if (is_target(target_pos).x == 1) {
                        // updater, swap values
                        int target_val = texelFetch(cells, target_pos, 0).r;
                        FOut.r = target_val;
                    }
                }

                // choose new windows
                vec3 rng_1 = hash(ivec3(I, seed + 1.0));
                FOut.r |= 15;
                FOut.r -= 15;
                if (rng_1.x < 0.6094757) {
                    FOut.r += 1 << 3;
                } else {
                    FOut.r += int(rng_1.y * 8.0);
                }
            }
        `}, { ...this.get_target_params() })
    },
    draw: function() {
        glsl({
            offset: [
                -pan.x / cell_size,
                pan.y / cell_size,
            ],
            scale: zoom.scale,
            max_scale: zoom.max_scale,
            cells: glsl.buffers.cells_int[0],
            num_texture,
            FP: `
            uniform isampler2D cells;

            void fragment() {
                ivec2 cells_size = textureSize(cells, 0);
                vec2 offset_uv = vec2(offset) / vec2(cells_size);
                vec2 uv = mod(UV / scale + offset_uv, vec2(1));

                ivec4 f = texture(cells, uv);
                FOut = vec4(vec3(0), 1);
                int val = f.r >> 4;
                FOut.r = float(val) / 16.0;

                // numbers
                vec2 num_uv = uv * vec2(cells_size);
                num_uv = mod(num_uv, vec2(1));
                num_uv *= 4.0;
                num_uv -= 0.5;
                num_uv = clamp(num_uv, vec2(0, 1), vec2(3, 2));
                int display_num = (val / int(pow(10.0, 2.0 - floor(num_uv.x))) % 10);
                num_uv.x = mod(num_uv.x, 1.0);
                num_uv.x += float(display_num);
                num_uv /= vec2(10, 1);
                float num_visibility = smoothstep(max_scale / 8.0, max_scale, scale);
                FOut.rgb = mix(FOut.rgb, vec3(1), num_texture(num_uv).a * num_visibility);
            }
        `})
    },
    interact: function(mx_square, my_square) {
    },
})

const updaters = [
    huemap,
    r8_cycle,
    add_max,
    uhh,
    uhh2,
    power,
    event_pairs,
    learn_add,
]
let updater_index = 0

function get_updater() {
    return updaters[updater_index]
}

let last_cycle_time;
function cycle_updater(dir = 1) {
    updater_index = mod(updater_index + dir, updaters.length)
    last_cycle_time = millis()
}


let mouse_buttons_down = { 0: false, 1: false, 2: false }
let ui_pressed = false
const pan = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: false,
}
const zoom = {
    scale: 1,
    max_scale: 20,
    vel_factor: 1,
}
let paused = false
let cell_size = 4

let glsl
let num_graphics, num_texture

function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL)
    glsl = SwissGL(canvas)

    const tag_ups = {}
    for (const up of updaters.toReversed()) {
        // note: r8 can use same shader as rgba32f,
        // but tag "cells" will keep the format it's first
        // initialized to (no gba if init with r8)
        tag_ups[up.get_target_params().tag] = up
    }
    for (const up of Object.values(tag_ups)) {
        up.init()
    }

    frameRate(60)
    document.addEventListener("contextmenu", e => e.preventDefault())

    num_graphics = createGraphics(360, 44)
    const g = num_graphics
    g.scale(1, -1)
    g.translate(0, -44)
    g.clear()
    g.noStroke()
    g.fill(255)
    g.textAlign(g.LEFT, g.CENTER)
    g.textFont("Courier New", 60)
    g.text("0123456789", 0, 26)
    g.loadPixels()
    num_texture = new TextureTarget(glsl.gl, {
        size: [g.width, g.height],
        format: "rgba8",
        data: g.pixels,
    })
}

function mousePressed(e) {
    if (e.target !== canvas) { return }
    if (e.detail > 1) {
        e.preventDefault()
    }
    if (e.button in mouse_buttons_down) {
        mouse_buttons_down[e.button] = true
    }

    if (e.button == 0) {
        for (const b of get_buttons()) {
            if (b.text === undefined) {
                continue
            }
            if (b.action && mouse_in_rect(b)) {
                ui_pressed = true
                b.action()
                break
            }
        }
    } else if (e.button == 2) {
        pan.held = true
    }
}

function mouseReleased(e) {
    if (e.button in mouse_buttons_down) {
        mouse_buttons_down[e.button] = false
    }

    if (e.button == 0) {
        ui_pressed = false
    } else if (e.button == 2) {
        pan.held = false
    }
}

// better version of mouseIsPressed
function mouseIsDown(button) {
    if (button === undefined) {
        for (const b in mouse_buttons_down) {
            if (mouse_buttons_down[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse_buttons_down && mouse_buttons_down[button]
}

function mouseWheel(e) {
    const buttons = get_buttons()
    const cycle_button = buttons.find(b => (b.text && b.text() || "").startsWith("cycle"))
    if (mouse_in_rect(cycle_button)) {
        if (millis() - (last_cycle_time || 0) > 100) {
            cycle_updater(sign(e.deltaY))
            last_cycle_time = millis()
        }
    } else {
        zoom.vel_factor -= e.deltaY / 2000
    }

    e.preventDefault()
}


document.addEventListener("mouseleave", e => {
    pan.held = false
})

function keyPressed(e) {
    if (key === " ") {
        paused = !paused
    } else if (key === "r") {
        get_updater().init()
    } else if (key === "Tab") {
        panel_open = !panel_open
    } else if (key === "d") {
        cycle_updater()
    } else if (key === "a") {
        cycle_updater(-1)
    }
}

document.addEventListener("keydown", e => {
    // includes held repeat
    if (e.key === "ArrowRight") {
        get_updater().update()
    }
})

function interact() {
    if (mouseIsDown(0) && !ui_pressed) {
        const aspect = width / height
        const w = width, h = height
        const mx = mod(mouseX / zoom.scale - pan.x, w)
        const my = mod(h - (h - mouseY) / zoom.scale - pan.y, h)
        let mx_square, my_square
        if (aspect > 1) {
            mx_square = (w / 2 + (mx - w / 2) * aspect) / w
            my_square = 1 - my / h
        } else {
            mx_square = mx / w
            my_square = 1 - (h / 2 + (my - h / 2) / aspect) / h
        }

        get_updater().interact(mx_square, my_square)
    }
}

function update() {
    if (!paused) {
        get_updater().update()
    }
    interact()

    // todo: framerate independence, smoothing
    if (pan.held) {
        const dx = (mouseX - pmouseX) / zoom.scale
        const dy = (mouseY - pmouseY) / zoom.scale
        pan.xv = dx
        pan.yv = dy
        pan.x += dx
        pan.y += dy
    } else {
        pan.xv *= 0.9
        pan.yv *= 0.9
        pan.x += pan.xv
        pan.y += pan.yv
    }

    // zoom
    const pscale = zoom.scale
    zoom.scale *= zoom.vel_factor
    zoom.max_scale = 20 * 4 / cell_size
    zoom.scale = clamp(zoom.scale, 1, zoom.max_scale)
    zoom.vel_factor = lerp(zoom.vel_factor, 1, 0.2)

    // update pan to keep mouse in place
    const mouse_uv = [mouseX / width, (1 - mouseY / height)]
    const delta_uv = [
        mouse_uv[0] * (1 / pscale - 1 / zoom.scale),
        mouse_uv[1] * (1 / pscale - 1 / zoom.scale),
    ]
    pan.x -= width * delta_uv[0]
    pan.y += height * delta_uv[1]

    // keep pan in bounds for easier interaction
    pan.x = mod(pan.x, width)
    pan.y = mod(pan.y, height)

    // panel animation
    panel_open_t += panel_open ? 0.1 : -0.1
    panel_open_t = clamp(panel_open_t, 0, 1)
}

setInterval(() => {
    // print cell count and action event rate for power
    if (!paused && get_updater().name === "power") {
        const size = glsl.buffers.cells_int2[0].size
        const n = size[0] * size[1]
        const aer = (frameRate() * 0.34992).toFixed(3)
        console.log(`${n.toLocaleString()} cells, AER: ${aer}`)
    }
}, 1000);

function draw() {
    update()
    get_updater().draw()
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight)
}

const button_data = [
    {
        text: () => paused ? "play " : "pause",
        action: () => paused = !paused,
    },
    {
        text: () => "reset",
        action: () => {
            get_updater().init()
        },
    },
    // {},
    {
        text: () => "√∑2",
        action: () => {
            cell_size = max(cell_size / 2, 1 / 4)
            get_updater().update()
        },
    },
    {
        text: () => `cell size:\n${cell_size}`,
    },
    {
        text: () => "√ó2",
        action: () => {
            cell_size *= 2
            get_updater().update()
        },
    },
    // {},
    {
        text: () => "step",
        action: () => get_updater().update(),
    },
    {
        text: () => `cycle rule:\n${get_updater().name}`,
        action: cycle_updater,
    },
]
const panel_height = 100
const spacing = 20
const padding = 10
let panel_open = true
let panel_open_t = 1

function get_buttons(p = ui_p) {
    let buttons_width = 0
    for (const b of button_data) {
        const b_text = b.text ? b.text() : ""
        buttons_width += p.textWidth(b_text) + padding * 2
    }
    buttons_width += (button_data.length - 1) * spacing

    const buttons = []
    let offset = (p.width - buttons_width) / 2
    for (const b of button_data) {
        const b_text = b.text ? b.text() : ""
        const b_width = p.textWidth(b_text) + padding * 2
        const n_lines = b_text.split("\n").length
        const vspace = (p.textLeading() - p.textSize()) * (n_lines - 1)
        const b_height = p.textSize() * n_lines + vspace + padding * 2
        const y_offset = (1 - ease.inOutCubic(panel_open_t)) * panel_height
        buttons.push({
            ...b,
            x: offset,
            y: p.height - (panel_height + b_height) / 2 + y_offset,
            w: b_width,
            h: b_height,
        })
        offset += b_width + spacing
    }

    const b_width = p.textSize() + padding * 2
    buttons.push({
        text: () => " ",
        action: () => {
            panel_open = !panel_open
        },
        x: p.width - b_width - spacing,
        y: p.height - panel_height / 2 - b_width / 2,
        w: b_width,
        h: b_width,
        is_panel_toggle: true,
    })

    return buttons
}

let ui_p
function ui_sketch(p) {
    ui_p = p
    p.setup = function() {
        p.createCanvas(p.windowWidth, p.windowHeight)
        p.canvas.style.pointerEvents = "none"
        p.frameRate(60)
        p.background(0)
        p.noStroke()
        p.textFont("Courier New", 28)
        p.textAlign(p.CENTER, p.CENTER)
    }
    p.draw = function() {
        document.body.style.cursor = "default"
        p.clear()
        p.fill(0, 100)
        const y_offset = (1 - ease.inOutCubic(panel_open_t)) * panel_height
        p.rect(0, p.height - panel_height + y_offset, p.width, panel_height)
        p.fill(255, 200)

        for (const b of get_buttons(p)) {
            if (b.text === undefined) {
                continue
            }
            if (b.action && p.mouseX >= b.x && p.mouseX <= b.x + b.w
                && p.mouseY >= b.y && p.mouseY <= b.y + b.h) {
                p.fill(0, 200)
                document.body.style.cursor = "pointer"
            } else {
                p.fill(0, 100)
            }
            p.rect(b.x, b.y, b.w, b.h, b.action ? 30 : 5)
            p.fill(255, 200)
            p.text(b.text(), b.x + b.w / 2, b.y + b.h / 2)

            if (b.is_panel_toggle) {
                p.push()
                const ease_t = ease.inOutCubic(panel_open_t)
                p.translate(
                    b.x + b.w / 2,
                    b.y + b.h / 2 + lerp(-2, 1, ease_t),
                )
                const pts = [
                    [0, -8],
                    [8, lerp(8, -8, ease_t)],
                    [0, 8],
                    [-8, lerp(8, -8, ease_t)],
                ]
                p.beginShape()
                for (const [x, y] of pts) {
                    p.vertex(x, y)
                }
                p.endShape(CLOSE)
                p.pop()
            }
        }
    }
    p.windowResized = function() {
        p.resizeCanvas(p.windowWidth, p.windowHeight)
    }
}
new p5(ui_sketch)

</script>
