<title>ğŸ‘ï¸</title>
<link rel=icon
    href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="1.1em" font-size="75">ğŸ‘ï¸</text></svg>'>
<style>
    html, body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: #262626;
    }
    canvas {
        position: absolute;
    }
</style>

<!-- fallback to cdn -->
<script src="lib/swissgl.js"></script>
<script>window.SwissGL || document.write('<script src="https://cdn.jsdelivr.net/gh/google/swissgl@main/swissgl.js">\x3C/script>')</script>
<script src="lib/p5.js"></script>
<script>window.p5 || document.write('<script src="https://cdn.jsdelivr.net/npm/p5@1.11.2/lib/p5.js">\x3C/script>')</script>

<script>
let mouse_buttons_down = { 0: false, 1: false, 2: false }
let ui_pressed = false
const pan = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: false,
}
const zoom = {
    scale: 1,
    vel_factor: 1,
}

function mod(x, n) {
    return fract(x / n) * n
}
function clamp(x, a, b) {
    return max(min(x, b), a)
}

const ease = {
    inQuad(t) { return t * t },
    outQuad(t) { return t * (2 - t) },
    inOutQuad(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
    inCubic(t) { return t * t * t },
    outCubic(t) { return (--t) * t * t + 1 },
    inOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
    inQuart(t) { return t * t * t * t },
    outQuart(t) { return 1 - (--t) * t * t * t },
    inOutQuart(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
    inQuint(t) { return t * t * t * t * t },
    outQuint(t) { return 1 + (--t) * t * t * t * t },
    inOutQuint(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
}

let glsl, cells
let paused = false

let cell_size = 4
function cells_target_params() {
    return {
        scale: 1 / cell_size / window.devicePixelRatio,
        format: "rgba32f",
        story: 2,
        tag: "cells",
    }
}

function init_cells() {
    return glsl({
        seed: Math.random() * 12417,
        FP: "hash(ivec3(I, seed)), 1",
    }, { ...cells_target_params() })
}

function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL)
    glsl = SwissGL(canvas)
    cells = init_cells()

    frameRate(60)
    document.addEventListener("contextmenu", e => e.preventDefault())
}

function mousePressed(e) {
    if (e.target !== canvas) { return }
    if (e.detail > 1) {
        e.preventDefault()
    }
    if (e.button in mouse_buttons_down) {
        mouse_buttons_down[e.button] = true
    }

    if (e.button == 0) {
        for (const b of get_buttons(ui_p)) {
            if (b.text === undefined) {
                continue
            }
            if (b.action && mouseX >= b.x && mouseX <= b.x + b.w
                && mouseY >= b.y && mouseY <= b.y + b.h) {
                ui_pressed = true
                b.action()
                break
            }
        }
    } else if (e.button == 2) {
        pan.held = true
    }
}

function mouseReleased(e) {
    if (e.button in mouse_buttons_down) {
        mouse_buttons_down[e.button] = false
    }

    if (e.button == 0) {
        ui_pressed = false
    } else if (e.button == 2) {
        pan.held = false
    }
}

// better version of mouseIsPressed
function mouseIsDown(button) {
    if (button === undefined) {
        for (const b in mouse_buttons_down) {
            if (mouse_buttons_down[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse_buttons_down && mouse_buttons_down[button]
}

function mouseWheel(e) {
    if (e.deltaY === 0) return
    zoom.vel_factor -= e.deltaY / 2000

    e.preventDefault()
}


document.addEventListener("mouseleave", e => {
    pan.held = false
    mouse_buttons_down = { 0: false, 1: false, 2: false }
})

function keyPressed(e) {
    if (key === " ") {
        paused = !paused
    } else if (key === "r") {
        cells = init_cells()
    } else if (key === "Tab") {
        panel_open = !panel_open
    }
}

document.addEventListener("keydown", e => {
    // includes held repeat
    if (e.key === "ArrowRight") {
        step();
    }
})

function step() {
    cells = glsl({
        seed: Math.random() * 12417,
        FP: `
        float sigmoid(float x) {
            return 1.0 / (1.0 + exp(-x));
        }

        void fragment() {
            // re-init on resize
            FOut = Src(I);
            vec3 rng_0 = hash(ivec3(I, seed));
            if (FOut.a == 0.0) {
                FOut = vec4(rng_0, 1);
                return;
            }

            // get random updater, get states
            vec3 rng_1 = hash(ivec3(I, seed + 1.0));
            ivec2 updater_offset = ivec2(round(rng_1.xy * 2.0 - 1.0));
            ivec2 updater_pos = (I + updater_offset + Src_size()) % Src_size();
            vec3 updater_state = Src(updater_pos).rgb;
            vec3 self_state = FOut.rgb;

            // mix based on relative distance from grey
            float updater_grey = dot(updater_state, vec3(1.0 / 3.0));
            float self_grey = dot(self_state, vec3(1.0 / 3.0));
            float updater_dist = length(updater_state - updater_grey);
            float self_dist = length(self_state - self_grey);
            float updater_rel_dist = updater_dist / (updater_dist + self_dist);
            float win_strength = 20.0;
            float updater_strength = sigmoid((updater_rel_dist - 0.5) * win_strength);
            vec3 new_state = mix(self_state, updater_state, updater_strength);

            // add noise
            vec3 rng_2 = hash(ivec3(I, seed + 2.0));
            float temperature = 0.01;
            new_state += (rng_2 * 2.0 - 1.0) * temperature;

            new_state = clamp(new_state, 0.0, 1.0);
            FOut = vec4(new_state, 1);
        }
        `,
    }, { ...cells_target_params() })
}

function interact() {
    if (mouseIsDown(0) && !ui_pressed) {
        const aspect = width / height
        const w = width, h = height
        const mx = mod(mouseX / zoom.scale - pan.x, w)
        const my = mod(h - (h - mouseY) / zoom.scale - pan.y, h)
        let mxSquare, mySquare
        if (aspect > 1) {
            mxSquare = (w / 2 + (mx - w / 2) * aspect) / w
            mySquare = 1 - my / h
        } else {
            mxSquare = mx / w
            mySquare = 1 - (h / 2 + (my - h / 2) / aspect) / h
        }

        const cur_cells = glsl({
            cells: cells[0],
            FP: "cells(I)",
        }, { ...cells_target_params(), story: 1, tag: "cur_cells" })
        glsl({
            seed: Math.random() * 12417,
            mouseSquare: [mxSquare, mySquare],
            brushSize: 0.1 / zoom.scale,
            cells: cur_cells[0],
            FP: `
            vec2 size = vec2(cells_size());
            float aspect = size.x / size.y;
            vec2 aspect_scale = (
                aspect > 1.0
                ? vec2(aspect, 1.0)
                : vec2(1.0, 1.0 / aspect)
            );
            vec2 uv_square = 0.5 + (UV - 0.5) * aspect_scale;
            for (int i = -1; i <= 1; ++i) {
                for (int j = -1; j <= 1; ++j) {
                    vec2 uv_tile = uv_square + vec2(i, j) * aspect_scale;
                    if (distance(uv_tile, mouseSquare) < brushSize) {
                        FOut = vec4(hash(ivec3(I, seed)), 1);
                        return;
                    }
                }
            }
            FOut = cells(I);
        `}, cells[0])
    }
}

function update() {
    if (!paused) {
        step()
    }
    interact()

    // TODO: framerate independence, smoothing
    if (pan.held) {
        const dx = (mouseX - pmouseX) / zoom.scale
        const dy = (mouseY - pmouseY) / zoom.scale
        pan.xv = dx
        pan.yv = dy
        pan.x += dx
        pan.y += dy
    } else {
        pan.xv *= 0.9
        pan.yv *= 0.9
        pan.x += pan.xv
        pan.y += pan.yv
    }

    // zoom
    const pscale = zoom.scale
    zoom.scale *= zoom.vel_factor
    zoom.scale = clamp(zoom.scale, 1, 40 / cell_size)
    zoom.vel_factor = lerp(zoom.vel_factor, 1, 0.2)

    // update pan to keep mouse in place
    const mouse_uv = [mouseX / width, (1 - mouseY / height)]
    const delta_uv = [
        mouse_uv[0] * (1 / pscale - 1 / zoom.scale),
        mouse_uv[1] * (1 / pscale - 1 / zoom.scale),
    ]
    pan.x -= width * delta_uv[0]
    pan.y += height * delta_uv[1]

    // keep pan in bounds for easier interaction
    pan.x = mod(pan.x, width)
    pan.y = mod(pan.y, height)

    // panel animation
    panel_open_t += panel_open ? 0.1 : -0.1
    panel_open_t = clamp(panel_open_t, 0, 1)
}

function draw() {
    update()
    glsl({
        offset: [
            -pan.x / cell_size,
            pan.y / cell_size,
        ],
        scale: zoom.scale,
        cells: cells[0],
        FP: `
        void fragment() {
            vec2 offset_uv = vec2(offset) / vec2(cells_size());
            vec2 uv = mod(UV / scale + offset_uv, vec2(1));
            FOut = cells(uv);
        }
    `})
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight)
}

const button_data = [
    {
        text: () => "reset",
        action: () => {
            cells = init_cells()
        },
    },
    {},
    {
        text: () => "Ã·2",
        action: () => {
            cell_size = max(cell_size / 2, 1 / 4)
            step()
        },
    },
    {
        text: () => `Cell Size:\n${cell_size}`,
    },
    {
        text: () => "Ã—2",
        action: () => {
            cell_size *= 2
            step()
        },
    },
    {},
    {
        text: () => "step",
        action: step,
    },
]
const panel_height = 100
const spacing = 20
const padding = 10
let panel_open = true
let panel_open_t = 1
function get_buttons(p) {
    let buttons_width = 0
    for (const b of button_data) {
        const b_text = b.text ? b.text() : ""
        buttons_width += p.textWidth(b_text) + padding * 2
    }
    buttons_width += (button_data.length - 1) * spacing

    const buttons = []
    let offset = (p.width - buttons_width) / 2
    for (const b of button_data) {
        const b_text = b.text ? b.text() : ""
        const b_width = p.textWidth(b_text) + padding * 2
        const n_lines = b_text.split("\n").length
        const vspace = (p.textLeading() - p.textSize()) * (n_lines - 1)
        const b_height = p.textSize() * n_lines + vspace + padding * 2
        const y_offset = (1 - ease.inOutCubic(panel_open_t)) * panel_height
        buttons.push({
            ...b,
            x: offset,
            y: p.height - (panel_height + b_height) / 2 + y_offset,
            w: b_width,
            h: b_height,
        })
        offset += b_width + spacing
    }

    const b_width = p.textSize() + padding * 2
    buttons.push({
        text: () => panel_open ? "â–¼" : "â–²",
        action: () => {
            panel_open = !panel_open
        },
        x: p.width - b_width - spacing,
        y: p.height - panel_height / 2 - b_width / 2,
        w: b_width,
        h: b_width,
    })

    return buttons
}

let ui_p
function ui_sketch(p) {
    ui_p = p
    p.setup = function() {
        p.createCanvas(p.windowWidth, p.windowHeight)
        p.canvas.style.pointerEvents = "none"
        p.frameRate(60)
        p.background(0)
        p.noStroke()
        p.textFont("Courier New", 28)
        p.textAlign(p.CENTER, p.CENTER)
    }
    p.draw = function() {
        document.body.style.cursor = "default"
        p.clear()
        p.fill(0, 100)
        const y_offset = (1 - ease.inOutCubic(panel_open_t)) * panel_height
        p.rect(0, p.height - panel_height + y_offset, p.width, panel_height)
        p.fill(255, 200)
        if (paused) {
            p.text("paused", 70, p.height - 20)
        }

        for (const b of get_buttons(p)) {
            if (b.text === undefined) {
                continue
            }
            if (b.action && p.mouseX >= b.x && p.mouseX <= b.x + b.w
                && p.mouseY >= b.y && p.mouseY <= b.y + b.h) {
                p.fill(0, 200)
                document.body.style.cursor = "pointer"
            } else {
                p.fill(0, 100)
            }
            p.rect(b.x, b.y, b.w, b.h, b.action ? 30 : 5)
            p.fill(255, 200)
            p.text(b.text(), b.x + b.w / 2, b.y + b.h / 2)
        }
    }
    p.windowResized = function() {
        p.resizeCanvas(p.windowWidth, p.windowHeight)
    }
}
new p5(ui_sketch)

</script>
